" vim: set foldmethod=marker:

" Early stuff {{{
	" These have to be put here in order to work, otherwise the plugin keybindings
	" don't pick up the leader change
	let mapleader = "\<space>"
	let maplocalleader = "-"
	" A word on runtimepath settings. {{{
		" Plug adds the rtps of its bundles to the beginning of an existing
		" runtimepath, and its bundle/after rtps at the end of the existing
		" runtimepath. Since Vim gives higher priority to files that are earlier
		" in the runtimepath, this leads to bundle settings having higher
		" precedence than user settings, which just shouldn't happen. In order
		" to alleviate that problem, I wait until after Plug has
		" initialized all its bundles before I set the remaining part of the
		" runtimepath. It should look like this:
		"
		"   u - b - s -- sa - ba - ua
		"
		"   u = User settings (highest priority)
		"   b = Bundle settings (second highest)
		"   s = System settings (lowest priority)
		"   sa = system after/ directories
		"   ba = Bundle after/ directories
		"   ua = User after/ directories
		"
		" This way, user settings take precedence before bundle and system settings,
		" both in the regular plugin/ftplugin directories as well as in the after/
		" directories. I believe this is the way it should be. }}}
	" Early runtimepath dickery!
	set runtimepath=$XDG_DATA_HOME/nvim/vim-plug,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after
	" Plugins {{{
		" Plug initialization {{{
			call plug#begin(expand("$XDG_DATA_HOME/nvim/bundle"))
			" Bundles
			" Vimproc has a native component
			Plug 'vim-scripts/argtextobj.vim'
			Plug 'tpope/vim-commentary'
			Plug 'vim-scripts/DeleteTrailingWhitespace', { 'on': 'DeleteTrailingWhitespace' }
			Plug 'jeetsukumaran/vim-filebeagle', { 'on': [
				\ 'FileBeagle', 'FileBeagleBufferDir'
				\ ] }
			Plug 'tpope/vim-fugitive'
			Plug 'airblade/vim-gitgutter', { 'on': [
					\ 'GitGutterEnable', 'GitGutterDisable', 'GitGutterToggle',
					\ 'GutGutterSignsEnable', 'GitGutterSignsDisable', 'GitGutterSignsToggle',
					\ 'GitGutterLineHighlightsEnable', 'GitGutterLineHighLightsDisable',
					\ 'GitGutterLineHighlightsToggle',
					\ '<Plug>GitGutterNextHunk', '<Plug>GitGutterPreviousHunk',
					\ '<Plug>GitGutterStageHunk', '<Plug>GitGutterRevertHunk',
					\ '<Plug>GitGutterPreviewHunk'
				\ ] }
			Plug 'sjl/gundo.vim', { 'on': [
					\ 'GundoToggle', 'GundoShow', 'GundoHide', 'GundoRenderGraph'
				\ ] }
			Plug 'michaeljsmith/vim-indent-object'
			Plug 'tpope/vim-obsession', { 'on': 'Obsession' }
			Plug 'tpope/vim-repeat'
			Plug 'tpope/vim-sensible'
			Plug 'altercation/vim-colors-solarized'
			Plug 'tpope/vim-speeddating'
			Plug 'vim-scripts/ShowTrailingWhitespace'
			Plug 'sjl/splice.vim'
			Plug 'tpope/vim-surround'
			Plug 'SirVer/ultisnips'
			Plug 'tpope/vim-unimpaired'
			Plug 'Shougo/unite.vim'
			Plug 'tpope/vim-dispatch', { 'on': [
					\ 'Dispatch', 'FocusDispatch', 'Make', 'Spawn', 'Start', 'Copen'
				\ ] }
			Plug 'Valloric/YouCompleteMe', { 'do':
					\ './install.sh --clang-completer --system-boost --system-libclang'
				\ }
			!!@@latex-plugin
			!!@@python-plugin
			!!@@as-plugin
			!!@@trabajo-plugin
			" Load last so extensions are properly supported
			Plug 'bling/vim-airline'

			call plug#end()
			filetype plugin indent on
		" }}}
		" Configuration {{{
			" Some preliminary remarks:
			" - all plugin functions that open some kind of split window have mapped that
			"   the opening/toggling of said window to a function key
			" - functions that toggle other stuff are normally either <leader><key> if I
			"   use them sparingly, or use their own keys if I use them often (e.g.
			"   commentary and üü)
			" Airline {{{
				" Use this theme
				let g:airline_theme = 'solarized'
				" Custom symbols dictionary
				if !exists('g:airline_symbols')
					let g:airline_symbols = {}
				endif
				" Separators between categories
				let g:airline_symbols.linenr = '¶'
				let g:airline_symbols.branch = '⎇ '
				let g:airline_symbols.readonly = '₩'
				let g:airline_symbols.paste = 'ρ'
				" Enable modified detection
				let g:airline_detect_modified = 1
				" Enable paste detection
				let g:airline_detect_paste = 1
				" Show a symbol in case of trailing whitespace
				let g:airline#extensions#whitespace#checks = [ 'trailing' ]
				" …but no message
				let g:airline#extensions#whitespace#show_message = 0
				" Define the text to display for each mode
				let g:airline_mode_map = {
					\ 'n'  : 'N',
					\ 'i'  : 'I',
					\ 'R'  : 'R',
					\ 'v'  : 'V',
					\ 'V'  : 'V',
					\ 'c'  : 'C',
					\ '' : 'V',
					\ }

			" }}}
			" DeleteTrailingWhitespace {{{
				" Don't automatically delete on writing a buffer
				let g:DeleteTrailingWhitespace = 0
				" Do this to fix trailing whitespace
				noremap <silent> <leader>d<space> :DeleteTrailingWhitespace<cr>

			" }}}
			" Fugitive {{{
				" Mnemonic: v = "VCS"
				" Edit fugitive-revision (with repo basedir as working directory)
				noremap <buffer> <leader>ve<space> :Gedit<space>
				" Edit fugitive-revision in split
				noremap <buffer> <leader>ves :Gsplit<space>
				" Edit fugitive-revision in vertical split
				noremap <buffer> <leader>vev :Gvsplit<space>
				" Edit fugitive-revision in new tab
				noremap <buffer> <leader>vet :Gtabedit<space>
				" Edit fugitive-revision in preview window
				noremap <buffer> <leader>vet :Gpedit<space>
				" Read output of git command in current buffer
				noremap <buffer> <leader>vE :Gread!<space>
				" Read output of git command in new split
				noremap <buffer> <leader>veS :Gsplit!<space>
				" Read output of git command in vertical split
				noremap <buffer> <leader>veV :Gvsplit!<space>
				" Read output of git command in new tab
				noremap <buffer> <leader>veT :Gtabedit!<space>
				" Read output of git command in preview window
				noremap <buffer> <leader>veP :Gpedit!<space>
				" :cd relative to repository
				noremap <buffer> <leader>vcd :Gcd<space>
				" :lcd relative to repository
				noremap <buffer> <leader>vcl :Glcd<space>
				" Move file and rename buffer accordingly
				noremap <buffer> <leader>vm :Gmove<space>
				" Move file and rename buffer accordingly (overwrite if necessary)
				noremap <buffer> <leader>vM :Gmove!<space>
				" Do :w and stage results
				noremap <silent> <buffer> <leader>vw :Gwrite<cr>
				" Do :w, stage results, do :q
				noremap <silent> <buffer> <leader>vwq :Gwq<cr>
				" Do :w and stage results
				noremap <silent> <buffer> <leader>vW :Gwrite!<cr>
				" Do :w, stage results, do :q
				noremap <silent> <buffer> <leader>vwQ :Gwq!<cr>
				" Remove current file and delete buffer
				noremap <buffer> <leader>vrm :Gremove<cr>
				" Remove current file and delete buffer forcefully
				noremap <buffer> <leader>vrM :Gremove!<cr>
				" Open annotation window ("git blame", but who's counting)
				noremap <silent> <buffer> <leader>va :Gblame<cr>
				" Browse on GitHub, if possible
				noremap <silent> <buffer> <leader>vb :Gbrowse<cr>
				" Put GitHub URL in clipboard
				noremap <silent> <buffer> <leader>vB :Gbrowse!<cr>
				" Open status window
				noremap <silent> <buffer> <leader>vs :Gstatus<cr>
				" Show list of revisions for current file in location list
				noremap <silent> <buffer> <leader>vl :Gllog<cr>
				" Show list of commits for current file in location list
				noremap <silent> <buffer> <leader>vL :Gllog --<cr>
				" Open diff window
				noremap <silent> <buffer> <leader>vd :Gsdiff<cr>
				" Open vertical diff window
				noremap <silent> <buffer> <leader>vvd :Gvdiff<cr>
				" :Glgrep
				noremap <buffer> <leader>vg :Glgrep<space>
				" :Ggrep
				noremap <buffer> <leader>vG :Ggrep<space>
				" Open commit buffer (or status buffer if there's nothing staged)
				noremap <silent> <buffer> <leader>vC :Gcommit<cr>
			" }}}
			" Git Gutter {{{
				" I'd like to do my own mappings, thanks
				let g:gitgutter_map_keys = 0
				" On, off, toggle
				nnoremap <silent> [ogg :GitGutterEnable<cr>
				nnoremap <silent> ]ogg :GitGutterDisable<cr>
				nnoremap <silent> cogg :GitGutterToggle<cr>
				" On, off, toggle (line highlights)
				nnoremap <silent> [ogs :GitGutterSignsEnable<cr>
				nnoremap <silent> ]ogs :GitGutterSignsDisable<cr>
				nnoremap <silent> cogs :GitGutterSignsToggle<cr>
				" On, off, toggle (line highlights)
				nnoremap <silent> [ogl :GitGutterLineHighlightsEnable<cr>
				nnoremap <silent> ]ogl :GitGutterLineHighlightsDisable<cr>
				nnoremap <silent> cogl :GitGutterLineHighlightsToggle<cr>
				" Move between hunks
				nmap <silent> [h <Plug>GitGutterPrevHunk
				nmap <silent> ]h <Plug>GitGutterNextHunk
				" Stage a hunk
				nmap <silent> <leader>hs <Plug>GitGutterStageHunk
				" Revert a hunk
				nmap <silent> <leader>hr <Plug>GitGutterRevertHunk
				" Update signs for current buffer
				nnoremap <silent> <leader>gu :GitGutter<cr>
				" Update signs for current buffer
				nnoremap <silent> <leader>gu :GitGutterAll<cr>
			" }}}
			" Gundo {{{
				" Toggles the Gundo windows
				noremap <leader>u :GundoToggle<cr>
				" horizontal width of Gundo graph
				let g:gundo_width = 50
				" Vertical height of preview window
				"let g:gundo_preview_height = 25
				" Show preview window below file instead of below graph
				" let g:gundo_preview_bottom = 0
				" Show Gundo graph on the right
				"let g:gundo_right = 1
				" automatically close Gundo windows on reverting
				let g:gundo_close_on_revert = 1

			" }}}
			" Obsession {{{
				" Sets up keybinding, invoked in autocmd below
				" Place for session file depends on whether current file is in Git/Hg repo or
				" not: For repos, session file is $reporoot/.session.vim, for non-repo files,
				" the session file is saved at ./.session.vim
				function! s:obsession() " {{{
					if exists('b:mercurial_dir')
						let dir = fnamemodify(b:mercurial_dir, ':p:h')
					elseif exists('b:git_dir')
						" b:git_dir points to the actual .git directory
						let dir = fnamemodify(b:git_dir, ':p:h:h')
					else
						let dir = fnamemodify(getcwd(), ':p:h')
					endif
					let fname = fnameescape(dir . "/.session.vim")
					execute 'Obsession ' . fname
				endfunction " }}}
				noremap <silent> <leader>o :call <SID>obsession()<cr>
				noremap <silent> <leader>O :Obsession!<cr>
			" }}}
			" ShowTrailingWhitespace {{{
				" Show it by default
				let g:ShowTrailingWhitespace = 0
				" ZOMGWTFBBQ
				" I mean, toggle trailing whitespace display for current buffer
				noremap <silent> co<space> :<c-u>call ShowTrailingWhitespace#Toggle(0)<bar>echo (ShowTrailingWhitespace#IsSet() ? 'Showing trailing whitespace' : 'Not showing trailing whitespace')<cr>

			" }}}
			" Solarized {{{
				set background=dark
				colorscheme solarized
		"	" }}}
			" SpeedDating {{{
				" I'd like to use my own mappings, thanks
				let g:speeddating_no_mappings = 1
				nmap  <C-A>     <Plug>SpeedDatingUp
				nmap  <C-X>     <Plug>SpeedDatingDown
				xmap  <C-A>     <Plug>SpeedDatingUp
				xmap  <C-X>     <Plug>SpeedDatingDown
				nmap k<C-A>     <Plug>SpeedDatingNowUTC
				nmap k<C-X>     <Plug>SpeedDatingNowLocal
			" }}}
			" Splice {{{
				" Use this as the splice prefix
				let g:splice_prefix = "<leader>s"
				" Use scrollbind on all modes
				let g:splice_initial_scrollbind_grid = 1
				let g:splice_initial_scrollbind_loupe = 1
				let g:splice_initial_scrollbind_compare = 1
				let g:splice_initial_scrollbind_path = 1

			" }}}
			" Surround {{{
				" I'd like to use my own mappings, thanks
				let g:surround_no_mappings = 1
				nmap ks <Plug>Dsurround
				nmap cs <Plug>Csurround
				nmap cS <Plug>CSurround
				nmap ys <Plug>Ysurround
				nmap yS <Plug>YSurround
				nmap yss <Plug>Yssurround
				nmap ySs <Plug>YSsurround
				nmap ySS <Plug>YSsurround
				xmap S <Plug>VSurround
				xmap gS  <Plug>VgSurround
				" I don't use the substitute command in visual/select mode anyways
				xmap s <Plug>VSurround
			" }}}
			" UltiSnips {{{
				" Snippet directory for private snippets
				let g:UltiSnipsSnippetsDir = expand("$XDG_CONFIG_HOME/nvim/snips")
				" All snippets directories, in case I use predefined snippets
				let g:UltiSnipsSnippetDirectories = ["snips", "UltiSnips"]
				" Use this to expand a trigger (i.e. insert a snippet)
				let g:UltiSnipsExpandTrigger = "<c-j>"
				" Use this to jump forward to next trigger
				let g:UltiSnipsJumpForwardTrigger = "<c-j>"
				" Use this to jump backward to next trigger
				let g:UltiSnipsJumpBackwardTrigger = "<c-k>"

			" }}}
			" Unite {{{
				" Info:
				" - -buffer-name and -resume together speed up subsequent openings of that buffer, even if the content changes
				" - -toggle allows to toggle with the same keybinding
				" - -no-split replaces the current viewport with the unite buffer

				" Unite conflicts with powerline
				let g:unite_force_overwrite_statusline = 0
				" Track yank history with unite
				let g:unite_source_history_yank_enable = 1
				" Use XDG spec compliant data directory
				let g:unite_data_directory = expand("$XDG_CACHE_HOME/nvim/unite")
				" Use fuzzy matcher
				call unite#filters#matcher_default#use(['matcher_fuzzy'])
				" Use unite for displaying ag search results
				let g:unite_source_grep_command = 'ag'
				let g:unite_source_grep_default_opts = '--nocolor --nogroup --hidden'
				let g:unite_source_grep_recursive_opt = ''

				" Open buffer list of all tabs in current window
				noremap <silent> <leader>b :Unite -no-split -toggle -buffer-name=buffers -start-insert buffer<cr>
				" Find file recursively
				" Note: Uses vimproc for asynchronous access
				noremap <silent> <leader>e :Unite -no-split -toggle -buffer-name=files -start-insert file_rec/neovim:!<cr>
				" Open yank history
				noremap <silent> <leader>y :Unite -no-split -toggle -buffer-name=yanks -resume history/yank<cr>
				" Grep through current buffer
				noremap <leader>g :Unite -no-split -toggle -buffer-name=grep grep:%::<cr>
				" Grep through all open buffers
				noremap <leader>G :Unite -no-split -toggle -buffer-name=grep grep:$buffers::<cr>

			" }}}
			" YouCompleteMe {{{
				" Don't open the location list on :YcmDiags
				let g:ycm_open_loclist_on_ycm_diags = 0
				" Fewer logging messages
				let g:ycm_server_log_level = 'warning'
				" Close preview window after completion
				let g:ycm_autoclose_preview_window_after_completion = 1
				" Interpret relative paths as relative to the current buffer
				" (instead of relative to the current working directory)
				let g:ycm_filepath_completion_use_working_dir = 1

			" }}}
			!!@@python-plugin-conf
		" }}}

	" }}}
	" Late runtimepath dickery!
	set runtimepath^=$XDG_CONFIG_HOME/nvim runtimepath+=$XDG_CONFIG_HOME/nvim/after

" }}}
" General {{{
	" I want to use LaTeX as my main TeX flavor, thank you very much
	" Also, it's kind of a pain in the ass having to set this in .vimrc, though
	" that's probably just my ignorance speaking
	let g:tex_flavor = "latex"

	" Files {{{
		" Don't create backup files
		set nobackup
		" Save viminfo file to keep state information from one vim session to the next
		set viminfo+="n$XDG_CACHE_HOME/nvim/viminfo"
		" Common directory for all swap files (first existing directory is used)
		set directory=$XDG_CACHE_HOME/nvim/swap
		" Persistent undo (see ":help persistent-undo")
		set undofile
		" Common directory for persistent undo files
		set undodir=$XDG_CACHE_HOME/nvim/undo

	" }}}
	" Indentation & linebreaks {{{
		" A tab is displayed as 4 spaces
		set tabstop=4
		" Number of spaces to use for each step of (auto)indent
		" A value of 0 uses tabstop
		set shiftwidth=0
		" Use this when pressing <tab> instead of tabstop
		" Allows to keep tabstop at default value while editing as if it's set to
		" softtabstop width
		" Negative value uses shiftwidth
		set softtabstop=-1
		" Don't expand tabs to spaces
		set noexpandtab
		" Insert shiftwidth when pressing Tab at the beginning of a line
		set smarttab
	" }}}
	" Search {{{
		" highlight search hits
		set hlsearch
		" Case-insensitive search unless there are capital letters in search expression
		set ignorecase
		set smartcase
		" Use ":s///g" by default
		set gdefault

	" }}}
	" Tabs & buffers {{{
		" Lets you leave edited buffers without having to save them
		set hidden
		" When splitting, only split current viewport
		set noequalalways
		" When splitting, create new viewports below/right to current viewports
		set splitbelow
		set splitright
		" Prettify splits, diffs, folds
		set fillchars="vert: ,fold: ,diff: "
		" Jump to other windows in current tab if they contain the requested buffer
		set switchbuf=useopen

	" }}}
	" Appearance {{{
		" Breaks lines in sane places
		set linebreak
		" End of line characters
		set listchars=eol:↲,tab:⇄·,trail:␣,extends:⇢,precedes:⇠
		" Add this in front of line if line is too long for terminal
		set showbreak=↪

		" Not necessary because of powerline plugin
		set noshowmode
		" Show tabline only if there is >1 tab
		set showtabline=1

	" }}}
	" Mouse {{{
		" Use mouse
		set mouse=a

	" }}}
	" Completion {{{
		" Show a popup even if there's only one option
		" Show preview window
		" Complete to longest common substring
		set completeopt=menuone,preview,longest
		set wildmode=longest:full,full

	" }}}

" }}}
" Functions {{{
	" Customize  fold text: just fold text with length appended {{{
		function! CustomFoldText()
			"get first non-blank line
			let fs = v:foldstart
			while getline(fs) =~ '^\s*$' | let fs = nextnonblank(fs + 1)
			endwhile
			if fs > v:foldend
				let line = getline(v:foldstart)
			else
				let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
			endif

			let foldSize = 1 + v:foldend - v:foldstart
			let foldSizeStr = " (" . foldSize . " lines)"
			return line . foldSizeStr
		endfunction
		set foldtext=CustomFoldText()

	" }}}
	" Check if I should set up Lawrencium or Fugitive keybindings {{{
		function! s:setup_vcs_keybindings()
			if exists('b:keybindings_setup')
				return
			endif
			let b:keybindings_setup = 1

			if exists('b:mercurial_dir')
				call s:setup_lawrencium_mappings()
			elseif exists('b:git_dir')
				call s:setup_fugitive_mappings()
			endif
		endfunction

	" }}}

" }}}
" Keybindings {{{
	" Movement {{{
		" Use dtrn for hjkl {{{
			noremap <silent> d h
			noremap <silent> t j
			noremap <silent> r k
			noremap <silent> n l

			" Fix alllll the other mappings…
			" First: <c-h>, <c-m>, <c-l> are the new H, M, L
			noremap <silent> <c-h> H
			noremap <silent> <c-m> M
			noremap <silent> <c-l> L

			" d > k (Mnemonic: "k"ut instead of "d"elete)
			noremap <silent> k d
			noremap <silent> K D
			" t > j (Mnemonic: "j"ump towards)
			" Also, it's right next to f, which performs a similar function
			noremap <silent> j t
			noremap <silent> J T
			" Fuck it, H is line joining now…
			noremap <silent> H J
			" …and h is line splitting
			noremap <silent> h <esc>i<cr><esc>

			" r > s (Mnemonic: "s"ubstitute)
			noremap <silent> s r
			noremap <silent> S R
			" <c-u> is now redo
			noremap <silent> <c-u> <c-r>

			" n -> l, like in Vimperator: "l"ook
			noremap <silent> l n
			noremap <silent> L N

			" Easier movement between virtual lines
			noremap <silent> t gj
			noremap <silent> r gk
			noremap <silent> gt j
			noremap <silent> gr k

			" Easier movement between viewports
			nnoremap <c-d> <c-w>h
			nnoremap <c-t> <c-w>j
			nnoremap <c-r> <c-w>k
			nnoremap <c-n> <c-w>l

		" }}}

		" Use <tab> to teleport to matching parens
		map <tab> %

	" }}}
	" Command-line window {{{
		" Use Q for macros
		noremap Q q
		" q is often used to close transient windows, so being able to use it without
		" a delay is nice
		" I'll just use <c-f> on the command line to open the :,/, and ? windows
		noremap q <nop>

		" allow leaving cmdline-window with <esc>
		au CmdwinEnter * nnoremap <buffer> <esc> :quit<cr>
		" Select current line without having to enter insert mode
		au CmdwinEnter * nnoremap <buffer> <cr> i<cr>

	" }}}
	" Quickfix and location list windows {{{
		" Use unimpaired for the regularly used bracket commands
		" Re-read error file
		noremap <silent> <leader>cf :cgetfile<cr>
		" Re-read error file and jump to first error
		noremap <silent> <leader>cj :cfile<cr>
		" List all errors
		noremap <silent> <leader>cl :clist<cr>
		" Go to older quickfix error list
		noremap <silent> <leader>c- :colder<cr>
		" Go to newer quickfix error list
		noremap <silent> <leader>c+ :cnewer<cr>

		" NOTE: No location list command changes buffers
		" Re-read error file
		noremap <silent> <leader>lf :lgetfile<cr>
		" Re-read error file and jump to first error
		noremap <silent> <leader>lj :lfile<cr>
		" Go to older error location list
		noremap <silent> <leader>l- :lolder<cr>
		" Go to newer error location list
		noremap <silent> <leader>l+ :lnewer<cr>

	" }}}

	" Easier :nohl
	noremap <silent> <cr> :nohlsearch<cr>
	" Make Y behave like D and C
	noremap <silent> Y y$
	" Make , search forwards and <Shift-,> search backwards
	" noremap , ;
	noremap ; –

" }}}
